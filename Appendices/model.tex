 \chapter{Model}
 
 Beskriv grunder i hur modellen fungerar
 There are moves put inbetween each task
 Model deosn't deal with coordinates only times for movement between tasks
 The data used by the model can be generated using tools described in [appendix ??]
 The move time depends on if there is a change between the tasks, if there is a task, the change will be longer than usual.
 \\Terminology:\\
 The goal for the assembly is to assemble components. This is components fed to the assembly from the outside, for example button components. The final assembly is the complete assembly of components that make the final product. All the smaller assemblies before that are called sub-assemblies. For reasons explained further down, we will in this thesis call components such as buttons for \emph{primitve} components instead of just components.
 \subsection{Model varibles}
 \subsection{Variables}
 \subsubsection{Static variables}
 Static variables are variables that have a fixed value, or is a set or list containing fixed values.
 
 \begin{equation}\label{eq:1}
 nbrTasks \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:10}
 tasks = \{1 , \ldots , nbrTasks\}
 \end{equation}
 First we define the number of tasks to be scheduled. Each task is identified 
 \\\\
 As mentioned, this model is based on the technique of using predecessors to determine which task comes directly before another. This creates the need to have source and a sink node for each machine, we call them start tasks and goal tasks. As they are not provided as parameters, the model creates them and give them identifiers with numbers above the tasks to be scheduled. As seen later, this is a convenient way of numbering these tasks.
 \begin{equation}\label{eq:19}
 startTasks = \{nbrTasks+1 , \ldots , nbrTasks+nbrMachines\}
 \end{equation}
 As sources, the start tasks are the predecessors to the first tasks for each machine.
 
 \begin{equation}\label{eq:20}
 goalTasks = \{nbrTasks+nbrMachines+1 , \ldots , nbrTasks+nbrMachines \times 2\}\end{equation}
 As sinks, the goal tasks has the last task as predecessor for each arm.
 
 \begin{equation}\label{eq:21}
 allTasks = tasks \cup startTasks \cup goalTasks
 \end{equation}
 We group together all tasks in one set in order for a more readable notation further down.
 
 \begin{equation}\label{eq:2}
 nbrMachines \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:11}
 machines = \{1 , \ldots , nbrMachines\}
 \end{equation}
 Here we define the machines available for the assembly. A machine in this model is an arm.
 
 \begin{equation}\label{eq:3}
 nbrTools \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:12}
 tools = \{1 , \ldots , nbrTools\}
 \end{equation}
 \begin{equation}\label{eq:33}
 toolNeeded(t) \in tools, \; t \in tasks
 \end{equation} 
 These are the tools that can be fitted on an arm. The model assumes that there is a set of $nbrTools$ for each machine. I.e. if $nbrTools = 2$ and $nbrMachines = 2$, there is a set of tool $1$ and tool $2$ for machine $1$, and another set of tools $1$ and $2$ for machine $2$. There cannot be a combination of tools such as, for example, only tool $1$ for machine $1$ and a set of tools $1$ and $2$ for machine $2$.
 
 $toolNeeded(t)$ defines the tool task $t$ needs.
 
 \begin{equation}\label{eq:6}
 nbrComponents \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:13}
 components = \{1 , \ldots , nbrComponents\}
 \end{equation}
 \begin{equation}\label{eq:25}
 componentsUsed(t) \subset components, \; t \in tasks
 \end{equation}
 \begin{equation}\label{eq:componentCreated}
 componentCreated(t) \in components \cup \{0\}, \; t \in tasks
 \end{equation}
 $nbrComponents$ defines the number of components used. All components needs to be uniquely identified in the assembly, so even if we use 4 screws in an assembly, we need to define all 4 screws. As mentioned before we distinguish between components and \emph{primitve} components. The reason for that is that in the model we do not distinguish between a \emph{primitve} component and a sub-assembly, they are the same. And in the model we call them components. The reason for this is because we found it easier to only have one sort of object to deal with when it comes to what will be assembled, instead of two. This means that the final assembly is also a component, i.e. the product produced by the assembly is a component. In other words, in this thesis \emph{primitve} components and sub-assemblies are sub sets of components.
 
 $componentsUsed(t)$ defines the set of components task $t$ uses. A task usually only uses one component at a time, but uses two in the case of mounting tasks, the mounted component and the component mounted on.
 
 To know when a sub-assembly is created we set is as $compoentCreated$ for the task where it is created. This cannot happen anywhere else other than at a mount task, although there is no check in the model for it. If there is not component created at a task, $componentCreated=0$
 \\\\
 Since components also can be sub-assemblies, it means a component can have subcomponents. These have been grouped in different groups to assist the constraints.
 \begin{equation}\label{eq:53}
 taskSubComponents(t) \subset components, \; t \in tasks\end{equation}
 $taskSubComponents(t)$ is the set of components that make up the subcomponents for the components used in task $t$. One can think of the subcomponents as layers with the component on top, call it origin component, and the layer below are the components that make up that component, and so on. $taskSubComponents(t)$ contains the components one layer down, if the component itself is not a \emph{primitve} component. In that case, $taskSubComponents(t)$ contains that component instead.
 
 \begin{equation}\label{eq:54}
 taskCompleteSubComponents(t) \subset components, \; t \in tasks\end{equation}
 To use the layer metaphor again, $taskCompleteSubComponents(t)$ contains all the layers below the origin component, for all the components in task $t$. Not including the origin components themselves. If the origin component is a \emph{primitve} component, the set is empty.
 
 \begin{equation}\label{eq:55}
 subComponents(c) \subset components, \; c \in components\end{equation}
 $subComponents(c)$ contains only the the \emph{primitve} subcomponents for component $c$, one layer down. If $c$ is a \emph{primitve} component or is only made of sub-assemblies, the set is empty.
 
 \begin{equation}\label{eq:4}
 nbrTrays \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:14}
 trays = \{1 , \ldots , nbrTrays\}
 \end{equation}
 \begin{equation}\label{eq:22}
 tray(t) \in trays \cup \{0\}, \; t \in tasks
 \end{equation}
 The trays available in the assembly, $trays$. Trays are used to hold components until we need them in the assembly. This can be that the tray holds the components from the beginning, as with \emph{primitve} components fed to the assembly, or it can be a sub-assembly put there during the assembly to be picked up again later. Each \emph{primitve} component has its own tray, so we can have a button tray, a cover tray, etc.
 
 $tray(t)$ is the tray task $t$ uses. If no tray is used by the task, $tray(t) = 0$.
 
 
 \begin{equation}\label{eq:5}
 nbrFixtures \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:15}
 fixtures = \{1 , \ldots , nbrFixtures\}
 \end{equation}
 \begin{equation}\label{eq:24}
 fixture(t) \in fixtures \cup \{0\}, \; t \in tasks
 \end{equation}
 $fixtures$ defines the fixtures available in the assembly. A fixture is primarily used to hold a component in order for another component to be mounted on that component. Although, as will be shown in the assembly example [section?], the fixture can be used for purposes than just holding components.
 
 $fixture(t)$ is the fixture task $t$ uses. If no fixture is used by the task, $fixture(t) = 0$
 
 \begin{equation}\label{eq:7}
 nbrOutputs \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:16}
 outputs = \{1 , \ldots , nbrOutputs\}
 \end{equation}
 \begin{equation}\label{eq:23}
 output(t) \in outputs \cup \{0\}, \; t \in tasks
 \end{equation}
 $outputs$ defines the outputs available. An output is the final stage for a component in an assembly. After it is put here, it will not be removed. Although, there can still be other components mounted on the component put on the output. In that respect an output can be viewed as a fixture, only that the components put there can not be removed.
 
 $output(t)$ is the output used by task $t$. If no output is used by the task, $output(t) = 0$.
 
 
 \begin{equation}\label{eq:8}
 nbrConcurrentGroups \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:17}
 concurrentGroups = \{1 , \ldots , nbrConcurrentGroups\}
 \end{equation}
 \begin{equation}\label{eq:30}
 concurrentTasks(k) \subset tasks, \; k \in concurrentGroups
 \end{equation}
 $concurrentTasks(k)$ is the $k$:th concurrent group among the concurrent groups defined. A concurrent group is a group of tasks that has to be performed at the same time. Hence, a concurrent group can not be larger than the amount of machines available, although, there is no check for it in the model. 
 
 The $k$ set of tasks needing concurrent execution
 $nbrConcurrentGroups$ defines the number of concurrent groups used. 
 
 \begin{equation}\label{eq:9}
 nbrOrderedGroups \in \{1 , \ldots , 2^{32}-1\}
 \end{equation}
 \begin{equation}\label{eq:9}
 orderedGroups = \{1 , \ldots , nbrOrderedGroups\}
 \end{equation}
 \begin{equation}\label{eq:18}
 orderedGroup(k) \subset tasks, \; k \in orderedGroups
 \end{equation}
 \begin{equation}\label{eq:32}
 ordered(k,i) \in tasks, \; i \in \{1 , \ldots , |orderedGroup(k)|\}, \; k \in orderedGroups
 \end{equation}
 \begin{equation}\label{eq:39}
 orderedSet = \bigcup_{\forall k \in orderedGroups}order(k), \; orderedSet \subset tasks\end{equation}
 $orderedGroup(k)$ is the $k$:th ordered group specified, there are $nbrOrderedGroups$ ordered groups. An ordered group is an array of tasks that has to come in a very specific order. An example of this could be if an assembly has many move tasks that needs to be performed one after another in order to make an intricate movement. As will be showed in the constraints[section?], we can reason the relation between tasks if they use a certain component and are a certain kind of action. But we can not reason using two move tasks, there is no way to tell which should come before the other based on the component they use. 
 
 $orderedGroup(k)$ is an array and the tasks in it will be scheduled in the order they com in the array. All the tasks in the group will be performed on the same machine, it can not order tasks on different machines.
 
 If one wants to access a certain task in a group, one can use $ordered(k,i)$ to access the $i$:th element of the $k$:th group.
 
 $orderedSet$ is the set of all tasks included in an ordered group.
 \\\\
 $tray(t)$, $output(t)$ and $fixture(t)$ can not be set at the same time for a task, since that would mean the task is performed at two locations at the same time, although this is not checked by the model. The only restriction for what kind of tasks can be performed using these are that output can not be used by a take task and tray can not be used by a mount task. If ones assembly contains these combinations, the output or tray should be changed to a fixture.
 
 \begin{equation}\label{eq:26}
 mounting \subset tasks
 \end{equation}
 \begin{equation}\label{eq:27}
 taking \subset tasks
 \end{equation}
 \begin{equation}\label{eq:28}
 moving \subset tasks
 \end{equation}
 \begin{equation}\label{eq:29}
 putting \subset tasks
 \end{equation}
 Each task performed can be classified as either a mount task, a take task, a move task or a put task, but only one of them.
 \begin{description}
 \item[Taking] A task that picks up a component is a taking task. The location of the component is specified by either a tray or a fixture, but not an output since there is no reason to pick up something that has been placed on an output.
 
 \item[Mounting] A task that mounts a component on another component is a mounting task. This assumes that the component to mount is picked up and in the hand. The location of the component to mount on is defined by either a fixture or an output.
 
 \item[Putting] A task that puts a component somewhere is a putting task. Where a component is put is defined by either a fixture, a tray or an output.
 
 \item[Moving] A task that moves a components from one place to another is a moving task. The model already puts in moves between tasks and if, for example, the first task is a take task and the second task is a put task, the move in between them is essentially a move that moves a component from one place to the another. Although, sometimes it can be handy to define a task that explicitly moves a component. An example of that can be if one wants to spin a component around. Then one can specify a take task in order to pick up the component, a move task to turn it, and a put task to put the component back. In this case there will be three moves of the component; one to move from the take task to the move task, the move task itself, and a move from the move task to the put task.
 \end{description}
 \begin{equation}\label{eq:35}
 putting(c) \subset putting, \; c \in components
 \end{equation}
 \begin{equation}\label{eq:36}
 mounting(c) \subset mounting, \; c \in components
 \end{equation}
 \begin{equation}\label{eq:37}
 taking(c) \subset taking, \; c \in components
 \end{equation}
 \begin{equation}\label{eq:38}
 moving(c) \subset moving, \; c \in components
 \end{equation}
 $putting(c)$, $mounting(c)$, $taking(c)$ and $moving(c)$ are subsets of respective set above based on the component involved.
 
 \begin{equation}\label{eq:42}
 duration(t) \in \{0 , \ldots , 2^{32}-1\}, \; t \in tasks
 \end{equation}
 $duration(t)$ is simply the duration of task $t$.
 \\\\
   \begin{figure}
   	\centering
    	\input{Figures/3d_matrix}
    	% or use \input{mytikz}
    	\caption{The timeMatrix3D}
    	\label{fig:3d_matrix}
   \end{figure}
 For the model to decide how long a move between two tasks should be and if there should be a change of tool in between, a matrix is used, $timeMatrix3D$, see figure \ref{fig:3d_matrix}. This is a 3-dimensional matrix and contains the times for moving between all the tasks depending on what tool change occurs. On its y-axis it has the tasks to move from, on the x-axis the tasks to move to, and on the z-axis the different transitions between tools that can occur.
 \begin{equation}\label{eq:timeMatrixDepth}
 timeMatrixDepth = \frac{n^2 - n + 2}{2}, \; n = nbrTools
 \end{equation}
  \begin{equation}
  \begin{aligned}\label{eq:44}
  timeMatrix3D(t(from),t(to),k) &\in \{0 , \ldots , 2^{32}-1\},\\
  t(from) &\in tasks \cup startTasks,  \\ 
  t(to) &\in tasks, \; k \in \{0 , \ldots , timeMatrixDepth\}
  \end{aligned}
  \end{equation}
 $timeMatrixDepth$ is the length of the z-axis, i.e. the depth of the matrix. It should be said that the reason for using the method described below is to reduce the size of the matrix and avoid too much redundancy.
 
 What we mean with ''different transitions'' is easiest to show through an example. Lets say we have $3$ tools available for each machine. We consider each tool state as a node in a graph, see figure \ref{fig:tools_trans_bef}, with the old tool state to the left and the new tool state to the right. Between them we can draw the different ways we can change state. The we start to consider which ones we actually need. We can change from tool $1$ to tool $1$, which is not changing tool at all. The same can be done for tool $2$, but not changing tool here costs just as much time as with tool $1$. So the change from tool $1$ to itself covers not changing tool for this tool, as well as for all the other tools, thereby we only need to keep track of one of these changes. We can also change from tool $1$ to tool $2$. And we can change back from $2$ to $1$, although here in the model we assume the change from one tool to another takes the same time the other way around as well. Therefore, we consider the change from tool $1$ to tool $2$ the same as from tool $2$ to tool $1$, and only keep track of one of them. If we keep consider the rest of the transitions this way, we will end up with a reduced number of transitions, in our case $4$, see figure \ref{fig:tools_trans_aft}
 
 It has been observed that using the reasoning above, $timeMatrixDepth$ follows the function \ref{eq:timeMatrixDepth}.
 
 \begin{figure}
 	\centering
 	\input{Figures/tool_trans_bef}
 	% or use \input{mytikz}
 	\caption{All the transitions between the tool states}
 	\label{fig:tools_trans_bef}
 \end{figure}
 
 \begin{figure}
 	\centering
  	\input{Figures/tool_trans_aft}
  	% or use \input{mytikz}
  	\caption{The reduced number of transitions between the tool states}
  	\label{fig:tools_trans_aft}
 \end{figure}
 
 \begin{equation}\label{eq:56}
 taskOutOfRange(m) \subset tasks, \; m \in machines
 \end{equation}
Depending on the physical layout of the assembly, sometimes not all tasks can be done with all machines. It could be that the machines would collide or simply that the spatial location is out of reach for the machine. In those cases we can specify tasks are out of hand for a specific machine. This is the only time when we distinguish between the two machines and connect the machine in the model model with the machine in the real world. In all other aspects other than this the machines in the model are identical and has the potential perform the same work.
 
 
 \subsubsection{Decision variables}
 Decision variables are variables that can take on many values. It is these values that the solver set out to determine in order to solve the problem.
 
 \begin{equation}\label{eq:40}
 usingMachine(t) \in machines, \; t \in tasks
 \end{equation}
 The model has to decide which task uses which machine.
 
 \begin{equation}\label{eq:41}
 pred(t) \in allTasks, \; t \in allTasks
 \end{equation}
Each task has a predecessor that tells the model what other task comes right before the task in question on the same machine.
 
 \begin{equation}
 \begin{aligned}\label{eq:maxE}
 maxE = &(max(\{duration(t) : t \in tasks\}) \; +  \\ 
 &\begin{aligned}
 max(\{&timeMatrix3D(t_1,t_2,k) : \\
 &\forall t_1 \in tasks \cup startTasks,  \\ 
 &\forall t_2 \in tasks,\\
 &\forall k \in \{0 , \ldots , timeMatrixDepth\}\}) \times nbrTasks
  \end{aligned}
 \end{aligned}
 \end{equation}
 In order to create an upper limit for variables dealing with time, we create a rough upper limit of the complete assembly. It simply takes the longest duration for a task and the longest duration for a move between tasks and assert it for all the tasks.
 
 \begin{equation}\label{eq:46}
 start(t) \in \{0 , \ldots , maxE\}, \; t \in allTasks
 \end{equation} 
 \begin{equation}\label{eq:47}
 end(t) = start(t) + duration(t), \; t \in allTasks
 \end{equation}
Each task has to start have a start time. We set it to be anywhere between time $0$ and the maximum possible end calculated before.

To simplify notation we also introduce one more variable called $end(t)$. It is the time when task $t$ ends and is simply the sum of the start and the duration of the task.

 \begin{equation}\label{eq:49}
 moveDuration(t) \in \{0 , \ldots , maxE\}, \; t \in allTasks
 \end{equation}
 \begin{equation}\label{eq:50}
 moveStart(t) \in \{0 , \ldots , maxE\}, \; t \in allTasks
 \end{equation}
 \begin{equation}\label{eq:51}
 moveEnd(t) = moveStart(t) + moveDuration(t), \; t \in allTasks
 \end{equation}
As mentioned before, each task has a move time connected to it since it takes a certain amount of time to move from one task to another. Since this time depends on both what task comes before it and what tools is needed for both of the tasks, the duration for the move is a decision variable as opposed to the duration for the task itself.
 
 \begin{equation}\label{eq:48}
 makespan \in \{0 , \ldots , maxE\}\end{equation}
Since the goal of the assembly is to complete the assembly in as little time as possible, we set up a variable for it, $makespan$. It is this variable the solver will try to minimize.
 
 \begin{equation}\label{eq:52}
 toolUsed(t) \in tools, \; t \in allTasks\end{equation}
The last variable is for determine what tool should be used for a task. With $toolNeeded$ we specify what tool is needed for the specific task. But we do not need to specify a tool if the task does not need any specific tool. That is why we need to determine what tool should be used for those tasks. Leaving the option open by not specifying any particular tool opens up for optimisations since it could mean we can avoid costly tool changes.
  
 
 \section{Constraints}
 
 \begin{equation}\label{eq:92}
 (\forall t \in tasks) \; end(t) \le makespan
 \end{equation}
 All ends has to be lesser than the total end
 
 \begin{equation}\label{eq:93}
 (\forall t \in startTasks \cup goalTasks) \; start(t) = 0
 \end{equation}
 Start and goal tasks are not temporal tasks, i.e. they are timeless. Therefore, their start time is set to 0
 
 
 \begin{equation}
 \begin{aligned}\label{eq:94}
 &(\forall m \in machines) \\
 &\begin{aligned}
 usingMachine(nbrTasks + m) &= m \; \land\\
 usingMachine(nbrTasks + nbrMachines + m) &= m
 \end{aligned}
 \end{aligned}
 \end{equation}
 The start tasks and goal tasks are assigned to machines, thereby there are start and goal tasks assigned to every machine. Because of the way start and goal tasks are created, the start tasks starts with number $nbrTasks + 1$, and the corresponding goal task for a start task can be accessed by $startTask + nbrMachines$.
 
 \begin{equation}\label{eq:95}
 \begin{aligned}
 (\forall m &\in machines) \\
 (\forall t &\in tasksOutOfRange(m)) \\
 usingMachine(t) &\neq m
 \end{aligned}
 \end{equation}
 Setting the tasks that are out of range for each machine
 
 \subsection{Precedences}
 
 \begin{equation}
 \begin{aligned}\label{eq:96}
 (\forall comp &\in components) \\
 (\forall mountTask &\in mounting(comp)) \\
 (\forall putTask &\in putting(comp)) \\
 end(putTask) &\le moveStart(mountTask)
 \end{aligned}
 \end{equation}
 If a set of tasks on a component involves a mount task and a put task, the put task has to come before the mount task
 
 
 \begin{equation}
 \begin{aligned}\label{eq:97}
 \forall comp &\in components \\
 \forall mountTask &\in mounting(comp), \\
 \forall takeTask &\in taking(comp), \\
 end(takeTask) &\le moveStart(mountTask)
 \end{aligned}
 \end{equation}
 If a set of tasks on a component involves a mount task and a take task, the take task has to come before the mount task
 
 
 \begin{equation}
 \begin{aligned}\label{eq:98}
 \forall comp &\in components \\
 (\forall putTask &\in putting(comp), \; tray(putTask) > 0)\\
 (\forall takeTask &\in taking(comp), tray(putTask) = tray(takeTask))\\
 end(putTask) &\le moveStart(takeTask)
 \end{aligned}
 \end{equation}
 If a component has a put and take performed on it in a tray, the put has to come before the take.
 
 
 \begin{equation}
 \begin{aligned}\label{eq:99}
 (\forall f &\in fixtures) \\
 (\forall putTask &\in putting(comp), \; fixture(putTask) = f)\\
 (\forall takeTask &\in taking(comp), \; fixture(takeTask) = f \; \land \\
 &componentsUsed(putTask) \subset taskSubComponents(takeTask)) \\
 end(putTask) &\le moveStart(takeTask), \\
 \end{aligned}
 \end{equation}
 For every put action on a fixture, there is a take action. The put action has to come before the take action.
 
 \begin{equation}
 \begin{aligned}\label{eq:100}
 &(\forall f \in fixtures) \\
 &puts = [put : \forall put \in putting, \; fixture(put) = f], \\
 &takesForEachPut = [\{take : \forall take \in taking, \; fixture(take) = f, \\
 &componentsUsed(put) \subset taskCompleteSubComponent(take)\} : \forall put \in puts], \\
 &\begin{aligned}
 takes = [&\operatorname*{arg\,min}_{\forall take \in takesForEachPut(p)}{taskCompleteSubComponent(take)} : \\
 &\forall p \in \{1 , \ldots , |puts|\}], 
 \end{aligned}\\
 &\begin{aligned}
 cumulative(&[moveStart(task) : \forall task \in puts], \\ &[abs(end(takes(i))-moveStart(puts(i))) : \forall i \in \{1 , \ldots , |puts|\}], \\
 &[1 : \forall i \in \{1 , \ldots , |puts|\}],\\
 &1)
 \end{aligned}\\
 \end{aligned}
 \end{equation}
 The intervals between when components are put and then taken again cannot overlap on the same fixture.
 
 \begin{equation}
 \begin{aligned}\label{eq:101}
 (\forall group &\in \{1 , \ldots , nbrConcurrentGroups\}) \\
 (\forall t_1 &\in concurrentTasks(group)) \\
 (\forall t_2 &\in concurrentTasks(group) / \{t_1\}) \\
 start(t_1) &= start(t_2) \; \land \\
 usingMahine(t_1) &\neq usingMachine(t_2), \\
 \end{aligned}
 \end{equation}
 Concurrent tasks has to happen at the same time.
 
 \begin{equation}
 \begin{aligned}\label{eq:102}
 (\forall t_1 &\in tasks, \; componentCreated(t1) > 0) \\
 (\forall t_2 &\in tasks, \; componentCreated(t_1) \in compinentUsed(t_2)) \\
 moveStart(t_2) &\geq end(t_1) \\
 \end{aligned}
 \end{equation}
 Components cannot be used before they are created.
 
 \begin{equation}
 \begin{aligned}\label{eq:103}
 (\forall precTask &\in tasks) \\
 (\forall t &\in tasks, \; precTask \neq t,\\
 &componentUsed(precTask) \cup taskCompleteSubComponent(t) \subset\\
 &taskCompleteSubComponents(t),\\
 &componentsUsed(precTask) \cup taskCompleteSubComponents(t) \neq \emptyset)\\
 end(precTask) &\leq moveStart(t), \\
 \end{aligned}
 \end{equation}
 Task using a component cannot execute before all the tasks having it as subcomponent.
 
 \begin{equation}
 \begin{aligned}\label{eq:104}
 &\begin{aligned}
 (\forall f &\in fixtures) \\
 fixtureTasks &= [t : \forall t \in tasks, \; fixture(t) = f], 
 \end{aligned}\\
 &\begin{aligned}
 cumulative(&[start(t) : \forall t \in fixtureTasks],\\
 &[duration(t) : \forall t \in fixtureTasks],\\
 &[1 : t \in fixtureTasks],\\
 &1)
 \end{aligned}\\
 \end{aligned}
 \end{equation}
 Tasks on the same fixture cannot overlap.
 
 \begin{equation}
 \begin{aligned}\label{eq:105}
 &\begin{aligned}
 (\forall tr &\in trays) \\
 trayTasks &= [t : \forall t \in tasks, \; tray(t) = tr], 
 \end{aligned}\\
 &\begin{aligned}
 cumulative(&[start(t) : \forall t \in trayTasks],\\
 &[duration(t) : \forall t \in trayTasks],\\
 &[1 : t \in trayTasks],\\
 &1)
 \end{aligned}\\
 \end{aligned}
 \end{equation}
 Tasks on the same tray cannot overlap.
 
 \begin{equation}
 \begin{aligned}\label{eq:106}
 &\begin{aligned}
 (\forall o &\in outputs) \\
 outputTasks &= [t : \forall t \in tasks, \; output(t) = o], \\
 \end{aligned}\\
 &\begin{aligned}
 cumulative(&[start(t) : \forall t \in outputTasks], \\
 &[duration(t) : \forall t \in outputTasks], \\
 &[1 : t \in outputTasks], \\
 &1)
 \end{aligned}\\
 \end{aligned}
 \end{equation}
 Tasks on the same output cannot overlap.
 
 \begin{equation}\label{eq:107}
 (\forall t \in tasks) \; Start(t) \geq moveEnd(t)\end{equation}
 A task can only start after the move to it.
 
 \subsection{Predecessors}
 
 \begin{equation}\label{eq:108}
 (\forall t \in tasks) \; moveStart(t) \geq end(pred(t))\end{equation}
 A task has to start after its predecessor.
 
 \begin{equation}\label{eq:109}
 \begin{aligned}
 (\forall startTask &\in startTasks / \{nbrTasks + 1\}) \\
 pred(startTask) &= startTask + nbrMachines - 1
 \end{aligned}
 \end{equation}
 In order to create a circuit containing the sub circuits, for all start tasks, except the first one, the start tasks predecessor is the previous goal task.
 
 \begin{equation}\label{eq:110}
 pred(nbrTasks + 1) = nbrTasks + nbrMachines \times 2\end{equation}
 To complete the circuit, the first start tasks predecessor is the last goal task.
 
 \begin{equation}\label{eq:111}
 circuit(\{pred(t) : \forall t \in tasks\})\end{equation}
 The predecessors has to form a circuit.
 
 \begin{equation}
 \begin{aligned}\label{eq:112}
 (\forall c &\in components) \\
 (\forall mountTask &\in mounting(c)) \\
 puts &= \{p : \forall p \in putting(c),\\
 &(fixture(p) > 0 \land fixture(p) = fixture(mountTask)) \; \lor  \\
 &(output(p) > 0 \land output(p) = output(mountTask)) \; \lor  \\
 &(tray(p) > 0 \land tray(p) = tray(mountTask))\}, \\
 (\forall takeTask &\in taking(c), \; takeTask \notin orderedSet, \; puts = \emptyset) \\
 pred(mountTask) &= takeTask \\
 \end{aligned}
 \end{equation}
 If a set of tasks on a component involves a mount and a take task, but no move tasks or put task on the same fixture, tray or output as the mount, the take task is the predecessor of the mount task.
 
 \begin{equation}
 \begin{aligned}\label{eq:113}
 (\forall c &\in components, \; moving(c) = \emptyset)\\
 (\forall putTask &\in putting(c), \; tray(putTask) = 0)\\
 (\forall takeTask &\in taking(c))\\
 pred(putTask) &= takeTask
 \end{aligned}
 \end{equation}
 If a set of tasks on a component involves a put task not in a tray and a take task, and there is no moves involved, the take task has to be the predecessor of the put task.
 
 \begin{equation}
 \begin{aligned}\label{eq:114}
 &\begin{aligned}
 (\forall k &\in orderedGroups) \\
 (\forall i &\in \{1 , \ldots , |orderedGroup(k)|-1\}) 
 \end{aligned}\\
 &pred(ordered(k, i + 1)) = ordered(k, i) \\
 \end{aligned}
 \end{equation}
 Sets up the predecessors in accordance with the ordered groups.
 
 \begin{equation}\label{eq:115}
 \begin{aligned}
 (\forall t &\in tasks \cup goalTasks) \\
 usingMachine(t) &= usingMachine(pred(t)) 
 \end{aligned}
 \end{equation}
 A task has to use the same machine as its predecessor.
 
 \begin{equation}\label{eq:116}
 \begin{aligned}
 (\forall t &\in tasks) \\
 k &= abs(toolUsed(t) - toolUsed(pred(t))) + 1, \\
 moveDuration(t) &= timeMatrix3D(pred(t), \; t, \; k)
 \end{aligned}
 \end{equation}
 Take tasks has to use the same tool as its predecessor or do a change first.
 
 \begin{equation}\label{eq:117}
 (\forall t \in tasks, \; toolNeeded(t) \neq 0) \; toolUsed(t) = toolNeeded(t)
 \end{equation}
 Set the tool used for each task in accordance with $toolNeeded$.
 
 
 \section{Filter}
  In \cite{VilimBartak2002Batch} \cite{Vilim2002Precedence} \cite{VilimBartak2002Sequence} Vilím shows that filtering the domains of variables when, as in our case, using sequence dependent setup times can have a great effect on the runtime. Here we present a set of filters in order to minimize the domains of the variables.
  \subsection{Temporal filter}
  The largest domains in the model are the domains for the variables dealing with time, i.e. the temporal variables. Reducing those has the potential to cut much of the processing time.
  
  \begin{equation}
  \begin{aligned}\label{eq:57}
  &( \forall t \in tasks)\\
  &\begin{aligned}
  maxMoveDurs(t) = max(\{&timeMatrix3D(t,j,k) :\\
  &\forall j \in tasks, \\
  &\forall k \in \{1 , \ldots , timeMatrixDepth\},\\
  &j \neq t\})
  \end{aligned}
  \end{aligned}
  \end{equation}
   \begin{equation}
   \begin{aligned}\label{eq:58}
   &(\forall t \in tasks)\\
   &\begin{aligned}
   minMoveDurs(t) = min(\{&timeMatrix3D(t,j,k) :\\
   &\forall j \in tasks, \\
   &\forall k \in \{1 , \ldots , timeMatrixDepth\},\\
   &j \neq t\})
   \end{aligned}
   \end{aligned}
   \end{equation}
 We start with defining two variables, $maxMoveDurs(t)$ and $minMoveDurs(t)$. These contain the maximum duration and the minimum duration respectively for each task taken from the time matrix.
  
  \begin{equation}\label{eq:59}
 	maxEnd = \sum_{\forall t \in tasks} duration(t) + maxMoveDurs(t)
  \end{equation}
  \begin{equation}\label{eq:minEnd}
  	minEnd = \frac{\sum_{\forall t \in tasks} duration(t) + minMoveDurs(t)}{nbrMachines}
  \end{equation}
 By using the newly created variables we candefine yet another two. These define a new maximum for the total time of the assembly, $maxEnd$. It is similar to $maxE$ in equation \ref{eq:maxE}, although much more thorough in the filtering. These variables also define a new minimum for the total time of the assembly, it was earlier ju set to 0.
 
 To calculate the maximum end we look at the worst case scenario for the assembly. The worst case would be if all the tasks had to be done one after the other, one at a time, on the same machine and they would take the longest time, according to the time matrix, to move between them. See figure \ref{fig:worst_case}. This can simply be defined by summing the durations and maximum move durations for all the tasks.
 
 To calculate the minimum end we look at the best case scenario. The best case scenario is if all the tasks can be evenly scheduled over all machines, taking the shortest, according to the time matrix, time to move between them. See figure \ref{fig:best_case}. We can define this by summing up the durations and minimum move durations for all the task end divide the sum with the number of machines available. If the tasks can be perfectly evenly scheduled across all the machines, the total assembly time will be equal to $minEnd$, if they cannot $minEnd$ will always be smaller than the total assembly time.
 
  \begin{figure}
  	\centering
  	\input{Figures/worst_case}
  	% or use \input{mytikz}
  	\caption{The worst case assembly}
  	\label{fig:worst_case}
  \end{figure}
   \begin{figure}
   	\centering
   	\input{Figures/best_case}
   	% or use \input{mytikz}
   	\caption{The best case assembly}
   	\label{fig:best_case}
   \end{figure}
 \newpage
 We can now start using $maxEnd$ and $minEnd$ to filter variables
  \begin{equation}\label{eq:lim_start_over}
  \begin{aligned}
 &(\forall t \in allTasks)\\
 &start(t) \le maxEnd-duration(t)
  \end{aligned}
  \end{equation}
   \begin{equation}\label{eq:lim_start_under}
  \begin{aligned}
 &(\forall t \in Tasks)\\
 &start(t) \ge minMoveDurs(t)
  \end{aligned}
  \end{equation}
 We set and upper bound for the start of a task by setting it to happen at latest the duration of the task time units before the $maxEnd$, since the task has to have time to execute before the end.
 
 To set a lower bound for the start of a task, we simply reason that the move to the task can start at its earliest at time 0. Therefore, we limit the task to start earliest direct after the minimum move duration to it.
 
 The difference between \ref{eq:lim_start_over} and \ref{eq:lim_start_under} is that the upper limit can be set for all sorts of tasks, even the start and goal tasks, but the lower limit cannot be set for start and goal tasks. This is simply because the start and goal tasks do not have any move times to them since they are source and sink nodes.
 
  \begin{equation}\label{eq:63}
  (\forall t \in tasks) \; moveStart(t) \le maxEnd-(duration(t)+minMoveDurs(t))
  \end{equation}
  In order to limit the move start to a task we use the same reasoning as with start. But now we have to account for that there comes a task after the move and a duration of the move itself. So we have to subtract the duration of the task and the duration of the move. Since we do not know the exact length of the move, we have to use the value we know the duration can not be lower than, which is $minMoveDuration$.
  
  \begin{equation}\label{eq:66}
  \begin{aligned}
  makeSpan &\le maxEnd \land\\
  makespan &\ge minEnd
  \end{aligned}
  \end{equation}
  We have already calculated the limits for the whole assembly, $maxEnd$ and $minEnd$. Now we just enforce them on the makespan.
  
  \begin{equation}
  \begin{aligned}\label{eq:67}
  &(\forall t \in tasks)\\
  &\begin{aligned}
  (\forall i \in \{0 , \ldots , maxMoveDurs(t)\} / \{&timeMatrix3D(task,j,k) :\\
  &\forall j \in tasks,\\
  &\begin{aligned}
  &\forall k \in \{1 , \ldots , timeMatrixDepth\}\\
  &t \neq j\})
  \end{aligned}
  \end{aligned}\\
  &moveDuration(t) \neq i
  \end{aligned}
  \end{equation}
 We know that the value for move duration will be one of the values in the time matrix, hence we can restrict the duration to only those values. We do that by coming up with the values that the duration cannot assume, and limits the duration to not have those values in its domain.
  
  \begin{equation}
  \begin{aligned}\label{eq:69}
  &(\forall t \in tasks / taking) \\
  &moveStart(t) \ge min(\{duration(tt) + minMoveDurs(tt) : \forall tt \in taking\})
  \end{aligned}
  \end{equation}
  The first thing that has to happen to a component in the assembly is that is has to be picked up. So since the assembly starts out with empty machines the first thing that has to happen, with the exception of a tool change, is a take task. Therefore, we can limit that start of the tasks not being take tasks to happen at earliest after the task with the smallest sum of duration and minimum move duration.
  
  \begin{equation}
  \begin{aligned}\label{eq:70}
  &(\forall t \in tasks)\\
  &\begin{aligned}
  prevTasks = \{task : &\forall task \in tasks,\\
  &componentCreated(task) \in componentsUsed(t)\},
  \end{aligned}\\
  &\begin{aligned}
  nbrMachines &\ge |prevTasks|,\\
  0 &< |prevTasks|,
  \end{aligned}\\
  &start(t) \ge max(\{duration(pt) + minMoveDurs(pt) : \forall pt \in prevTasks\}) \\
  \end{aligned}
  \end{equation}
  The start of a task can be even further limited by analysing the components used by the task and how that relates to what components are created by other tasks.
  
  Lets take task $t$ as an example. We start by getting all tasks that creates the components that is used in task $t$, $prevTasks$. These tasks has to come before task $t$ since the component that they create cannot be used before they are created. If the number of machines are greater than or equal to the number of task preceding task t, then the best scheduling that can be done is to do all tasks in parallel. That means that task $t$ can start at earliest after the one of the proceeding tasks taking the longest to complete.
  
  \begin{equation}
  \begin{aligned}\label{eq:71}
  &(\forall t \in tasks) \\
  &\begin{aligned}
  prevTasks = \{task : &\forall task \in tasks,\\
  &componentCreated(task) \in componentsUsed(t)\},
  \end{aligned} \\
  &nbrMachines < |prevTasks|,  \\
  &start(t) \ge \frac{\left(\sum_{\forall pt \in prevTasks}duration(pt) + minMoveDurs(pt)\right)}{nbrMachines}
  \end{aligned}
  \end{equation}
  But if the number of machines is fewer than the number of preceding tasks, the best we can do is divide them as equally as possible over the machines. This is the same reasoning as when we calculated $minEnd$ in equation \ref{eq:minEnd}.
  
  \begin{equation}\label{eq:72}
  \begin{aligned}
  &(\forall t \in tasks) \\
  &succTasks = \{task : \forall task \in tasks,\\
  &componentsUsed(t) \subset taskCompleteSubComponent(task), \\
  &componentsUsed(t) \cup taskCompleteSubComponents(task) \neq \emptyset\}, \\
  &\begin{aligned}
  nbrMachines &\ge |succTasks|,\\
  0 &< |succTasks|,
  \end{aligned}\\
  &\begin{aligned}
  start(t) \le maxEnd - max(\{&duration(st) + minMoveDurs(st) :\\
  &\forall st \in succTasks\}) - duration(t)
  \end{aligned}\\
  \end{aligned}
  \end{equation}
  To set the upper limit for the start of tasks we use a little bit different strategy.
  
  We know that if a component $c$ has been mounted on another component, $c$ cannot be used again on its own. Therefore, a task that uses component $c$ has to come before the tasks that uses a component in which $c$ is a part of.
  
  We use the same strategy as in \ref{eq:70} and look at the best case scenario where the tasks are performed concurrently on all machines. The difference here from \ref{eq:70} is that here we have to look at the maximum end of the assembly and subtract the successor task which takes the longest to perform and the duration of the task in question.
  
  \begin{equation}\label{eq:73}
  \begin{aligned}
  &(\forall t \in tasks)\\
  &succTasks = \{task : \forall task \in tasks, \\
  &componentsUsed(t) \subset taskCompleteSubComponent(task), \\
  &componentsUsed(t) \cup taskCompleteSubComponents(task) \neq \emptyset\}, \\
  &nbrMachines \le |succTasks|, \\
  &\begin{aligned}
  start(t) \; \le \; &maxEnd - \frac{\left(\sum_{\forall st \in succTasks}duration(st) + minMoveDurs(st)\right)}{nbrMachines}\\
  &- duration(t)
  \end{aligned}
  \end{aligned}
  \end{equation}
  As with \ref{eq:71} we look at the worst case scenario.
  
  
  \subsection{Predecessor filter}
  Since the predecessors are searched by the solver before searching the start variables, reducing their domains has potential to help reduce the total runtime considerably.
  
  \begin{equation}\label{eq:74}
  alldifferent(\{pred(t) : \forall t \in tasks\})
  \end{equation}
 The \texttt{circuit} constraint already sees to it that the predecessors of the tasks forms a circuit. This means that all the predecessors will take on different values. However, we apply this \texttt{alldifferent} constraint in order to help the \texttt{circuit} make the predecessor variables take on different values.
  
  \begin{equation}\label{eq:75}
  (\forall t1, \forall t2 \in taking) \; pred(t1) \neq t2
  \end{equation}
  \begin{equation}\label{eq:76}
  (\forall t1, \forall t2 \in putting \cup mounting) \; pred(t1) \neq t2
  \end{equation}
 In our model the tools can only pick up one component at a time. This also means that if a task puts down a component or mounts one, there cannot be a mount or put task directly afterwards.
  
  \begin{equation}
  \begin{aligned}\label{eq:78}
  &(\forall t \in tasks)\\
  &nonPredecessors = \{t_2 : \forall t_2 \in tasks, \\
  &componentsUsed(t) \subset taskCompleteSubComponents(t_2) \; \lor \\
  &componentsUsed(t) \subset subComponents(componentCreated(t_2))\} \\
  &(\forall nonPred \in nonPredecessors) \\
  &pred(t) \neq nonPred, \\
  \end{aligned}
  \end{equation}
  Using a similar reasoning as in \ref{eq:72} and \ref{eq:73}, we can find the tasks that cannot be the predecessor of task $t$. We look at what tasks uses the components that has the components used in $t$ as sub-components. This means that those components cannot come before task $t$, and therefore cannot be predecessors of $t$.
  
  \begin{equation}\label{eq:79}
  \begin{aligned}
  &(\forall startTask \in startTasks)\\
  &(\forall putTask \in putting)\\
  &pred(putTask) \neq startTask
  \end{aligned}
  \end{equation}
  \begin{equation}\label{eq:80}
   \begin{aligned}
   &(\forall startTask \in startTasks)\\
   &(\forall mountTask \in mounting)\\
   &pred(mountTask) \neq startTask 
   \end{aligned}
  \end{equation}
  As mentioned before, a component has to be picked up first before it can be manipulate in any way and the assembly has to start with a take task. Therefore, we can say that an assembly cannot start with neither a put task nor a mount task.
  
  The same could be said for move tasks, but since they need to be in an ordered group, a constraint like these would no make any difference.
  
  \begin{equation}\label{eq:81}
  \begin{aligned}
  &(\forall goalTask \in goalTasks) \\
  &(\forall takeTask \in taking) \\
  &pred(goalTask) \neq takeTask
  \end{aligned}
  \end{equation}
  The same way we can observe that an assemble needs to start with a take task, we can observe that an assembly cannot end with a take task. There is no component in the assembly that does not end up in the finished assembly, therefore the assembly cannot end with a machine holding a component, since it needs to be on the output in some way. 
  
  \begin{equation}
  \begin{aligned}\label{eq:82}
  &\begin{aligned}
  counts &= \{i : \forall task \in outputTasks, \; i \in \{0 , \ldots , 1\}\}, \\
  outputTasks &= \{task : \forall task \in tasks, \; output(task) > 0\}, \\
  goalPreds &= \{pred(task) : \forall task \in goalTasks\},
  \end{aligned} \\
  &global\_cardinality(goalPreds, \; outputTasks, \; counts) \; \land\\
  &\sum counts > 0
  \end{aligned}
  \end{equation}
   \begin{equation}
   \begin{aligned}\label{eq:83}
   &\begin{aligned}
   counts &= \{i : \forall task \in startTasks, \; i \in \{0 , \ldots , 1\}\}, \\
   takePreds &= \{pred(task) : \forall task \in taking\}, 
   \end{aligned}\\
   &global\_cardinality(takePreds, \; startTasks, \; counts) \; \land\\
   &\sum counts > 0
   \end{aligned}
   \end{equation}
 Continuing the reasoning around what tasks can come first and not we can expand with which tasks has to come last. We cannot limit the last task on each arm to be on an output, because it does not necessarily need to be that. Although, among the last tasks in the assembly there needs to be a task on an output. We can easily check that by placing a constraint over the $pred$ variables for the goal tasks. This is what \ref{eq:82} says.
 
 We can do the same reasoning with what needs to come first in the assembly. As we stated before, a take task has to be the first task in the assembly. And as with the last tasks in the assembly, the first task of a machine does not have to be a take task, but there needs to be at least one take task among the first tasks. We ensure this in \ref{eq:83} by placing a constraint over the $pred$ variables for the take tasks.
  
   \begin{equation}
  \begin{aligned}\label{eq:85}
  (\forall comp &\in components) \\
  (\forall mountTask &\in mounting(comp)) \\
  (\forall takeTask &\in taking(comp)) \\
  pred(takeTask) &\neq mountTask
  \end{aligned}
  \end{equation}
  For all the tasks that operate on the same component we can restrict so the mount task of the component cannot be the predecessor of the take task. 
  
  \begin{equation}
  \begin{aligned}\label{eq:86}
  (\forall comp &\in components) \\
  (\forall putTask &\in putting{comp}, \; tray(putTask) > 0) \\
  (\forall takeTask &\in taking(comp), \; tray(putTask) = tray(takeTask)) \\
  pred(putTask) &\neq takeTask
  \end{aligned}
  \end{equation}
  We can also restrict the predecessor of a put task for a component to not be the take task for that component, if the two tasks are performed on the same tray. This can help in a situation when we want the assembly to put down a part for a moment and pick it up later, because if the part does not come in the tray from the beginning, i.e. it is not the component tray, we first need to put it in the tray before we are able to take it. 
  
  \begin{equation}
  \begin{aligned}\label{eq:87}
  (\forall f &\in fixtures) \\
  (\forall putTask &\in putting{comp}, \; fixture(putTask) = f) \\
  (\forall takeTask &\in taking(comp), \; fixture(takeTask) = f,\\
  &componentsUsed(putTask) \subset taskSubComponents(takeTask))\\
  pred(putTask) &\neq takeTask
  \end{aligned}
  \end{equation}
  For every put action on a fixture, there is a take action. The predecessor of the put task cannot be the take task.
  
  \begin{equation}
  \begin{aligned}\label{eq:88}
  (\forall group &\in \{1 , \ldots , nbrConcurrentGroups\}) \\
  (\forall t_1 &\in concurrentTasks(group)) \\
  (\forall t_2 &\in concurrentTasks(group) / \{t_1\}) \\
  pred(t_1) &\neq t_2 \land pred(t_2) \neq t_1
  \end{aligned}
  \end{equation}
  Since concurrent tasks need to happen simultaneously on different machines, they cannot be the predecessor to each other.
  
  \begin{equation}
  \begin{aligned}\label{eq:89}
  (\forall t_1 &\in tasks, \; componentCreated(t_1) > 0) \\
  (\forall t_2 &\in tasks, \; componentCreated(t_1) \in componentUsed(t_2)) \\
  pred(t_1) &\neq t_2
  \end{aligned}
  \end{equation}
 Sub-assembly components can only be used after they are created. Therefore, we can say that a task that uses a component created at task $t$ cannot be the predecessor of task $t$.
  
  \begin{equation}
  \begin{aligned}\label{eq:90}
  &(\forall precTask \in tasks) \\
  &(\forall t \in tasks, \; precTask \neq t,\\
  &\begin{aligned}componentUsed(precTask) \cup taskCompleteSubComponent(t) \subset\\
  taskCompleteSubComponents(t), \end{aligned}\\
  &componentsUsed(precTask) \cup taskCompleteSubComponents(t) \neq \emptyset \\
  &pred(precTask) \neq t
  \end{aligned}
  \end{equation}
 Referera \ref{eq:103}
  
  \begin{equation}
  \begin{aligned}\label{eq:91}
  (\forall concGroup &\in concurrentTasks, \; |concGroup| = nbrMachines) \\
  concComps &= \bigcup_{\forall i \in concGroup}componentsUsed(i), \\
  concSubComps &= \bigcup_{\forall i \in concGroup}taskCompleteSubComponents(i), \\
  postTasks &= \{postTask : \forall postTask \in tasks,\\
  &concComps \cap taskCompleteSubComponents(postTask) \neq \emptyset\}\\
  preTasks &= \{preTask : \forall preTask \in tasks,\\
  &componentsUsed(preTask) \cap concSubComps \neq \emptyset\}, \\
  (\forall postTask &\in postTasks) \\
  (\forall predTask &\in preTasks) \\
  pred(postTask) &\neq preTask
  \end{aligned}
  \end{equation}
  If there is a group of concurrently executing tasks that take up all machines available they will act as a wall between the tasks before and after the group. It is guaranteed that the tasks after the group cannot have the tasks before the group as predecessors. We can extract the tasks before and after the concurrent tasks by analysing the components used, since the components used in the concurrent tasks will have the components used before as sub-components.
