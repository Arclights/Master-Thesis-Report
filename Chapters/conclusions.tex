\chapter{Conclusions} \label{cha:conc}
Through this thesis we can conclude that the presented model representing the problem as a Job Shop Problem works well and can produce a result that is as good as the handmade solution.

We can also conclude that when it comes to choosing solvers there can be a very large difference in the performance. It can range from not being able to solve a problem in 4 hours to solve it in under 100 milliseconds. The best performance was achieved by Gecode in 60 milliseconds using the 2.0.1 version of MiniZinc. This is promising result for the new version. Interestingly the 1.6 version of the same solver could not solve the problem in 4 hours. But although the 2.0.1 version performed remarkably well for Gecode, two of the solvers were not able to read the FlatZinc file produced by that version, more specifically Opturion CPX and or-tools.

We tested applying filters that reduced the domains of temporal variables and predecessor variables. Our tests showed that these filters can have an positive inpact on the runtime result, and thereby confirming the results of Vil√≠m in \cite{VilimBartak2002Batch} \cite{Vilim2002Precedence} and \cite{VilimBartak2002Sequence}.

The analysis of the resulting FlatZinc files showed that there was no relation between the resulting FlatZinc file and the runtime of the solver. Moreover, we found no relation between the percentage of reified constraints and the runtime of the solver.


\section{Further work}

Since the result from the solver was not evaluated on physical robot it could be a suitable continuation to try out the result on an actual robot. It could show problems not seen in the result itself, such as collisions etc.
\\\\
In this thesis we present a set of filter constraints to reduce the domains of the variables. The tests performed compared the result of using the filters versus not using the filters. It is not necessarily the case that all filters are needed, and all filters do probably not perform equally well. Therefore it might be of interest to test the each individual filter for it self and compare the filters against each other to see which performs the best and take that experience to come up with further filters.
\\\\
Since MiniZinc does not have support for customized searches, customized searches are not doable in regular MiniZinc. But in \cite{Bjordal} they present a constraint-based local search solver that performs local search in order to improve the runtime. Although Ejenstam concludes that local search performs poorly on the data in that thesis, it might be worth looking into. In \cite{yuan_2013} they conclude that Large neighborhood Search in combination with Hybrid Harmony Search performed very well for instances of Flexible Job Shop Problem. To incorporate such a search in the solver of \cite{Bjordal} might be beneficial to models such as this.
\\\\
As mentioned, our ambition for this thesis was originally to be able to run Ejenstam's data on our model, but the extended search space prevented us from that. The testing when developing the model, and thereby the tests for the extension to be able to run Ejenstam's data, was performed only on JaCoP. But as we can see from the results, there are solvers that could perform better. Hence, there might be a possibility to solve Ejenstam's data using those solvers. If an incorporation of local search, as mentioned above, can be done, it would probably further the possibility to adapt the model to the data.
\\\\
As mentioned before, our model assumes that there are as many sets of all the tools defined as there are machines, so that each machine has its own set of tools. This simulates an ideal world where we have all the resources we want, when in fact we might be limited to a few sets of tools. To be able to do more realistic schedulings that considers the amount of tools available, there would need to be a considerable number of constraints added to the model and it might be worth looking into in future work.