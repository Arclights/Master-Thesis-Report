\chapter{Introduction} 

\section{Background}
More and more of the production in today's society is getting automated. Manufacturers want to cut cost and make the production more effective by eliminating the human work and replace it with robots. But there are drawbacks; robots are expensive and robots does not have the versatility of a human. This puts pressure on the robot manufacturers to develop robots that are more versatile. Thus eliminating the need for manufacturers to have multiple robots to do multiple tasks and thereby lowering costs. And also by making the robots more versatile the close the gap of what a human and robots are able to do.

Current robot setups usually have one robot performing one task all the time, as oppose to flexible robots which will be performing many different tasks and assemblies. This poses the demand for the scheduling of such robots to be flexible as well. A scheduling of a robot can be a time consuming task. Since manufacturers want as effective assemblies as possible, it can take from days to weeks to perfect an assembly schedule. This is not feasible if you want to use the robot for many different tasks and assemblies. In this thesis we would like to try and automate this scheduling process in order to cut down on the scheduling time. To accomplish this we will be using Constraint programming, as it provides a general interface to solve problems without needing to build a complete framework from scratch. Also, scheduling is a classical constraint problem, thus constraint programming suits this problem well.

One of those robots are ABB's robot YuMi\textregistered(formerly known as FRIDA). YuMi\textregistered is a dual armed robot made to work along side humans and able to perform the some of the most complex tasks, such as mount a nut or thread a needle.\cite{_yumi_} It accomplishes this by using a wide variety of sensors, e.g. force sensor, visual sensors, etc. Usually robot replaces humans to perform dangerous or heavy tasks, YuMi\textregistered is mainly designed for small parts assembly, i.e. usually humans roles in todays manufacturing environment.


\subsection{Constraint Programming}
Constraint programing is a \emph{declarative} paradigm. This means that in contrast to \emph{imperative} paradigm languages, such as C or Java, the focus of solving problems using constraint programming is on specifying the solution and not the algorithm to solve it. This is done by specifying the solution using \emph{domain variables}, or simply variables, and \emph{constraints}. Variables have a domain of values, meaning they can represent each value in their domain. Variables can often be, depending on language and solver, either integers, floating-points, boolean or symbolic, symbolic being a text or label. For example a symbolic variable representing a week would have the domain\\
$\{Monday,Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday\}$.

\subsubsection{Constraints}
Constraints are set up as relationships between the variables, and thereby limiting the domains of the variables. Integer domains are often used for variables, so for the rest of this section we will assume variables have integer domains. For this domain the following function symbols can be used: $+$, $\times$, $-$ and $\div$. The constraint relation symbols are $=$, $<$, $\leq$, $>$, $\geq$. Together with the function symbols and the constraint relation symbols, one can create simple constraint, called \emph{primitive constraints}. An example of a primitive constraint is $X < Y$, i.e.\ the values in $X$'s domain has to lower than in $Y$'s. Primitive constraints can be used to create more complex constraints using the conjunctive connective $\land$. An example of this is $X < Y \land Y < 10$, i.e.\ $Y$ has to be less than $10$ and $X$ has to be less than $Y$. Since all constraints has to hold when the model is evaluated, all constraints are joined in a conjunction.(\textbf{?}) The disjunctive connective $\lor$ is also available and can be used in the same way as $\land$. In some cases the logical implications; reverse implication ($\gets$), forward implication ($\to$) and bi-implication ($\leftrightarrow$) are also available. Here, for example, the implication works by taking two logical statement and if the first one evaluates to \emph{true} the other statement should hold as well. For example $X = 0 \to Y > 5$ says that if $X=0$ then $Y$ should be larger than $5$.

\begin{framed}
For example, we have a problem with the variables $x$ and $y$. $x = 4$ and $y = \{1..10\}$. Here the $x$ has the value $4$ and can thereby only assume the value $4$. $y$ on the other hand can assume the values $1$ to $10$. This means a solution to this problem can be $x = 4$ and $y = 1$ or likewise $x = 4$ and $y = 5$ , they are equally correct.\\
On this problem we can impose a constraint, for example $y > x$. Now we have set the constraint that $y$ needs to be larger than $x$. And since $x$ has a fixed known value we can directly see that $y > 4$, since $x = 4$. Now with this constraint, we can get rid of the lower part of $y$'s domain and now $y = \{5..10\}$ instead. And now a viable solution can be $x = 4$ and $y = 7$, but not $x = 4$ and $y = 3$.
\end{framed}

\begin{figure}
  \input{Figures/search_example}%     without .tex extension
  % or use \input{mytikz}
  \caption{The beginning of the search space for the variables $X$, $Y$, $Z$, where $X=\{1,3,6\}$ $Y=\{5,9,8\}$ $Z=\{6,3,5\}$}
  \label{fig:search_space}
\end{figure}

\subsubsection{Global constraints}
\subparagraph{AllDifferent}
\subparagraph{Circuit}
\subparagraph{Cumulative}
\subparagraph{Global_Cardinality}



\subsubsection{Solver}
A constraint programming program is consisting of many of these constraints and variables. When the solution is specified in a model, a \emph{solver} runs the model. The goal of the solver is to satisfy all the constraints, i.e. set the domains of the variables so that the all follow the relationships of the constraints. This is called the \emph{constraint satisfaction problem}, and can  be defined as a triple $\langle Z,D,C \rangle$. $Z=\{x_1 \ldots x_n\}$ is a finite set of all the variables in the solution, $D(x_i), \; x_i \in Z$ is a set representing the domain of values the variable $x_i$ can assume, $C$ is the set of constraints imposed on the variables in $Z$. The solver accomplishes this by doing a \emph{search} on the space of possibilities, i.e.\ the \emph{search space}. The search space is in the form of a tree, where each branch is a selection of a variable where the variables domain is reduced into a smaller subset that conforms with the constraints. The solver traverses the tree in search for a solution. When all variables are set to conform with the constraints a solution is found. If the solver reaches a node where a variables domain becomes empty, it has to \emph{backtrack} to a previous node from which it can choose a new variable to set, i.e.\ traversing a new branch of that node.

\cite{tsang_1993}
\cite{marriott_1998}
\cite{mz_manual}

\subsubsection{Reified}

\subsection{Job-shop scheduling problem}
\subsubsection{Flexible job-shop scheduling problem}



\section{Problem specification}
\subsection{The setup}
What does our problem look like

\section{Related work}
[brucker 2009] mentions the solving of 15x15 benchmark(15 jobs with 15 operations) being solved without heuristics (although not necessarily in CP).\cite{brucker_2009}
\\

[Th√∂rnblad] concludes that when a cell is part of an assembly flow, the use of targeting due dates is to prefer. Because makespan can exacerbate an already unreliable flow. The assembly we perform is not a part of a flow, and such we do not concern ourselves with maintaining a stable flow through the cell, but only to optimize the assembly in the cell.\cite{thornblad_2013}
\\

[Garey] shows that job shop problems for size $m \geq 2$ and $n \geq 3$ are NP-complete \cite{garey_1976}
\\

[yuan] says pure CP is only effective on small problems of FJSP. To effectively perform larger sizes, methods such as discrepancy search, large neighborhood search(LNS) or iterative flattening search. It also shows LNS together with Hybrid Harmonic Search produces good results.\cite{yuan_2013}
\\

[ejenstam]
[andra test med solvers]

\section{Report structure}
